import React, { useCallback, useMemo, useState } from 'react';
import {
  ReactFlow,
  addEdge,
  Controls,
  Background,
  MiniMap,
  Panel,
  type Node,
  type Edge,
  type Connection,
  useNodesState,
  useEdgesState,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import type { WorkflowNode, WorkflowEdge, Workflow } from '../types/workflow';
import { NODE_TYPES } from '../types/workflow';
import { Card } from './ui/card';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { NodeConfigPanel } from './NodeConfigPanel';
import { useAuth } from '../contexts/AuthContext';
import axios from 'axios';

interface WorkflowBuilderProps {
  workflow?: WorkflowNode[];
  onWorkflowChange?: (nodes: WorkflowNode[], edges: WorkflowEdge[]) => void;
}

const nodeTypes = {
  trigger: ({ data }: { data: any }) => (
    <Card className="p-3 bg-green-50 border-green-200 min-w-[200px]">
      <div className="text-sm font-medium text-green-800">{data.label}</div>
      <div className="text-xs text-green-600 mt-1">Trigger</div>
    </Card>
  ),
  condition: ({ data }: { data: any }) => (
    <Card className="p-3 bg-blue-50 border-blue-200 min-w-[200px]">
      <div className="text-sm font-medium text-blue-800">{data.label}</div>
      <div className="text-xs text-blue-600 mt-1">Condition</div>
    </Card>
  ),
  action: ({ data }: { data: any }) => (
    <Card className="p-3 bg-orange-50 border-orange-200 min-w-[200px]">
      <div className="text-sm font-medium text-orange-800">{data.label}</div>
      <div className="text-xs text-orange-600 mt-1">Action</div>
    </Card>
  ),
};

export const WorkflowBuilder: React.FC<WorkflowBuilderProps> = ({ 
  workflow = [], 
  onWorkflowChange 
}) => {
  const { user } = useAuth();
  const [nodes, setNodes, onNodesChange] = useNodesState(workflow);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [workflowName, setWorkflowName] = React.useState('Untitled Workflow');
  const [selectedNode, setSelectedNode] = useState<Node<WorkflowNode['data']> | null>(null);
  const [savedWorkflows, setSavedWorkflows] = useState<Workflow[]>([]);

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  const onNodeClick = useCallback((_event: React.MouseEvent, node: Node<WorkflowNode['data']>) => {
    setSelectedNode(node);
  }, []);

  const onPaneClick = useCallback(() => {
    setSelectedNode(null);
  }, []);

  const updateNodeConfig = useCallback(
    (config: Record<string, any>) => {
      if (!selectedNode) return;

      setNodes((nds) =>
        nds.map((node) =>
          node.id === selectedNode.id
            ? {
                ...node,
                data: {
                  ...node.data,
                  config: { ...node.data.config, ...config },
                },
              }
            : node
        )
      );
    },
    [selectedNode, setNodes]
  );

  const handleSaveWorkflow = useCallback(async () => {
    if (nodes.length === 0) {
      alert('Cannot save empty workflow');
      return;
    }

    const workflow: Workflow = {
      id: '', // Will be generated by backend
      name: workflowName,
      description: `Workflow with ${nodes.length} nodes and ${edges.length} connections`,
      userId: user?.email || 'anonymous',
      nodes: nodes.map(node => ({
        id: node.id,
        type: node.type as 'trigger' | 'condition' | 'action',
        position: node.position,
        data: node.data
      })),
      edges: edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target
      })),
      isActive: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    try {
      const response = await axios.post('http://localhost:8080/api/workflows', workflow);
      alert('Workflow saved successfully!');
      console.log('Saved workflow:', response.data);
    } catch (error) {
      console.error('Failed to save workflow:', error);
      alert('Failed to save workflow');
    }
  }, [nodes, edges, workflowName, user]);

  const handleTestWorkflow = useCallback(async () => {
    if (nodes.length === 0) {
      alert('Cannot test empty workflow');
      return;
    }

    // First save the workflow to get an ID
    const workflow: Workflow = {
      id: '',
      name: `Test: ${workflowName}`,
      description: `Test workflow with ${nodes.length} nodes`,
      userId: user?.email || 'anonymous',
      nodes: nodes.map(node => ({
        id: node.id,
        type: node.type as 'trigger' | 'condition' | 'action',
        position: node.position,
        data: node.data
      })),
      edges: edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target
      })),
      isActive: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    try {
      const saveResponse = await axios.post('http://localhost:8080/api/workflows', workflow);
      const workflowId = saveResponse.data.id;
      
      // Execute the workflow
      const executeResponse = await axios.post(`http://localhost:8080/api/workflows/${workflowId}/execute`);
      
      alert(`Workflow executed successfully!\n\nResults:\n${JSON.stringify(executeResponse.data, null, 2)}`);
      console.log('Execution result:', executeResponse.data);
    } catch (error) {
      console.error('Failed to test workflow:', error);
      alert('Failed to test workflow');
    }
  }, [nodes, edges, workflowName, user]);

  const handleLoadWorkflows = useCallback(async () => {
    try {
      const userId = user?.email || 'anonymous';
      const response = await axios.get(`http://localhost:8080/api/workflows?userId=${userId}`);
      setSavedWorkflows(response.data);
      
      if (response.data.length === 0) {
        alert('No saved workflows found');
      } else {
        const workflowNames = response.data.map((w: Workflow) => `${w.name} (ID: ${w.id})`).join('\n');
        alert(`Found ${response.data.length} saved workflows:\n\n${workflowNames}`);
      }
    } catch (error) {
      console.error('Failed to load workflows:', error);
      alert('Failed to load workflows');
    }
  }, [user]);

  const onDragStart = (event: React.DragEvent, nodeType: string, nodeData: any) => {
    event.dataTransfer.setData('application/reactflow', nodeType);
    event.dataTransfer.setData('application/reactflow-data', JSON.stringify(nodeData));
    event.dataTransfer.effectAllowed = 'move';
  };

  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const type = event.dataTransfer.getData('application/reactflow');
      const nodeDataStr = event.dataTransfer.getData('application/reactflow-data');
      
      if (typeof type === 'undefined' || !type) {
        return;
      }

      const reactFlowBounds = event.currentTarget.getBoundingClientRect();
      const nodeData = JSON.parse(nodeDataStr);

      const newNode: Node = {
        id: `${type}-${Date.now()}`,
        type,
        position: {
          x: event.clientX - reactFlowBounds.left - 75,
          y: event.clientY - reactFlowBounds.top - 25,
        },
        data: nodeData,
      };

      setNodes((nds) => nds.concat(newNode));
    },
    [setNodes]
  );

  const categorizedNodes = useMemo(() => {
    return NODE_TYPES.reduce((acc, nodeType) => {
      if (!acc[nodeType.category]) {
        acc[nodeType.category] = [];
      }
      acc[nodeType.category].push(nodeType);
      return acc;
    }, {} as Record<string, typeof NODE_TYPES>);
  }, []);

  return (
    <div className="h-screen flex">
      {/* Sidebar with node palette */}
      <div className="w-80 bg-white border-r border-gray-200 p-4 overflow-y-auto">
        <div className="mb-6">
          <Input
            placeholder="Workflow Name"
            value={workflowName}
            onChange={(e) => setWorkflowName(e.target.value)}
            className="font-medium"
          />
        </div>

        <div className="space-y-6">
          {Object.entries(categorizedNodes).map(([category, nodes]) => (
            <div key={category}>
              <h3 className="text-sm font-semibold text-gray-700 mb-3 capitalize">
                {category}
              </h3>
              <div className="space-y-2">
                {nodes.map((nodeType) => (
                  <Card
                    key={`${nodeType.type}-${nodeType.label}`}
                    className="p-3 cursor-move hover:shadow-md transition-shadow"
                    draggable
                    onDragStart={(event) => onDragStart(event, nodeType.type, {
                      label: nodeType.label,
                      config: {}
                    })}
                  >
                    <div className="text-sm font-medium">{nodeType.label}</div>
                    <div className="text-xs text-gray-500 mt-1">
                      {nodeType.description}
                    </div>
                  </Card>
                ))}
              </div>
            </div>
          ))}
        </div>

        <div className="mt-6 space-y-2">
          <Button className="w-full" variant="default" onClick={handleSaveWorkflow}>
            Save Workflow
          </Button>
          <Button className="w-full" variant="outline" onClick={handleTestWorkflow}>
            Test Workflow
          </Button>
          <Button className="w-full" variant="outline" onClick={handleLoadWorkflows}>
            Load Workflows
          </Button>
        </div>
      </div>

      {/* Main workflow canvas */}
      <div className="flex-1 relative">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onDrop={onDrop}
          onDragOver={onDragOver}
          onNodeClick={onNodeClick}
          onPaneClick={onPaneClick}
          nodeTypes={nodeTypes}
          fitView
        >
          <Controls />
          <MiniMap />
          <Background variant="dots" gap={12} size={1} />
          <Panel position="top-right">
            <Card className="p-3">
              <div className="text-sm font-medium">{workflowName}</div>
              <div className="text-xs text-gray-500">
                {nodes.length} nodes, {edges.length} connections
              </div>
            </Card>
          </Panel>
        </ReactFlow>

        {selectedNode && (
          <NodeConfigPanel
            node={selectedNode}
            onClose={() => setSelectedNode(null)}
            onUpdate={updateNodeConfig}
          />
        )}
      </div>
    </div>
  );
};